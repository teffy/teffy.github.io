<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[read-fucking-source-code-arouter]]></title>
    <url>%2Fread-fucking-source-code-arouter.html</url>
    <content type="text"><![CDATA[本文主要分享Arouter一些核心代码和一些流程分析。 Read fucking source code:Arouter 1、初始化12345com.alibaba.android.arouter.launcher.ARouter#initcom.alibaba.android.arouter.launcher._ARouter#initcom.alibaba.android.arouter.core.LogisticsCenter#initcom.alibaba.android.arouter.core.LogisticsCenter#loadRouterMap loadRouterMap这个方法，通过arouter-register实现编译代码之后自动注册路由信息，摒弃了之前的版本扫描dex文件解析class文件进行注册，也避免了造成的性能问题，原理，原理2初始化之后，会把所有注册的路由信息处理成 路由信息映射1234567891011121314151617181920212223com.alibaba.android.arouter.core.Warehouseclass Warehouse &#123; // Cache route and metas static Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = new HashMap&lt;&gt;(); static Map&lt;String, RouteMeta&gt; routes = new HashMap&lt;&gt;(); // Cache provider static Map&lt;Class, IProvider&gt; providers = new HashMap&lt;&gt;(); static Map&lt;String, RouteMeta&gt; providersIndex = new HashMap&lt;&gt;(); // Cache interceptor static Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = new UniqueKeyTreeMap&lt;&gt;(&quot;More than one interceptors use same priority [%s]&quot;); static List&lt;IInterceptor&gt; interceptors = new ArrayList&lt;&gt;(); static void clear() &#123; routes.clear(); groupsIndex.clear(); providers.clear(); providersIndex.clear(); interceptors.clear(); interceptorsIndex.clear(); &#125;&#125; RouteMeta 就是路由信息12345678910111213141516171819public class RouteMeta &#123; private RouteType type; // Type of route private Element rawType; // Raw type of route private Class&lt;?&gt; destination; // Destination private String path; // Path of route private String group; // Group of route private int priority = -1; // The smaller the number, the higher the priority private int extra; // Extra data private Map&lt;String, Integer&gt; paramsType; // Param type public enum RouteType &#123; ACTIVITY(0, &quot;android.app.Activity&quot;), SERVICE(1, &quot;android.app.Service&quot;), PROVIDER(2, &quot;com.alibaba.android.arouter.facade.template.IProvider&quot;), CONTENT_PROVIDER(-1, &quot;android.app.ContentProvider&quot;), BOARDCAST(-1, &quot;&quot;), METHOD(-1, &quot;&quot;), FRAGMENT(-1, &quot;android.app.Fragment&quot;), UNKNOWN(-1, &quot;Unknown route type&quot;); 2、inject把Uri上带的数据参数，给跳转目标中的class中使用com.alibaba.android.arouter.facade.annotation.Autowired 标记的成员变量赋值例如：12345678910111213public class Test1Activity extends AppCompatActivity &#123; @Autowired String name = &quot;jack&quot;; @Autowired int age = 10; @Autowired int height = 175; @Autowired(name = &quot;boy&quot;) boolean girl; 下面是通过gradle自动生成的代码12345678910111213141516171819202122232425262728293031323334public class Test1Activity$$ARouter$$Autowired implements ISyringe &#123; private SerializationService serializationService; @Override public void inject(Object target) &#123; serializationService = ARouter.getInstance().navigation(SerializationService.class); Test1Activity substitute = (Test1Activity)target; substitute.name = substitute.getIntent().getStringExtra(&quot;name&quot;); substitute.age = substitute.getIntent().getIntExtra(&quot;age&quot;, substitute.age); substitute.height = substitute.getIntent().getIntExtra(&quot;height&quot;, substitute.height); substitute.girl = substitute.getIntent().getBooleanExtra(&quot;boy&quot;, substitute.girl); substitute.ch = substitute.getIntent().getCharExtra(&quot;ch&quot;, substitute.ch); substitute.fl = substitute.getIntent().getFloatExtra(&quot;fl&quot;, substitute.fl); substitute.dou = substitute.getIntent().getDoubleExtra(&quot;dou&quot;, substitute.dou); substitute.pac = substitute.getIntent().getParcelableExtra(&quot;pac&quot;); if (null != serializationService) &#123; substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra(&quot;obj&quot;), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;TestObj&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(&quot;ARouter::&quot;, &quot;You want automatic inject the field &apos;obj&apos; in class &apos;Test1Activity&apos; , then you should implement &apos;SerializationService&apos; to support object auto inject!&quot;); &#125; if (null != serializationService) &#123; substitute.objList = serializationService.parseObject(substitute.getIntent().getStringExtra(&quot;objList&quot;), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;List&lt;TestObj&gt;&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(&quot;ARouter::&quot;, &quot;You want automatic inject the field &apos;objList&apos; in class &apos;Test1Activity&apos; , then you should implement &apos;SerializationService&apos; to support object auto inject!&quot;); &#125; if (null != serializationService) &#123; substitute.map = serializationService.parseObject(substitute.getIntent().getStringExtra(&quot;map&quot;), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;Map&lt;String, List&lt;TestObj&gt;&gt;&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(&quot;ARouter::&quot;, &quot;You want automatic inject the field &apos;map&apos; in class &apos;Test1Activity&apos; , then you should implement &apos;SerializationService&apos; to support object auto inject!&quot;); &#125; substitute.url = substitute.getIntent().getStringExtra(&quot;url&quot;); substitute.helloService = ARouter.getInstance().navigation(HelloService.class); &#125;&#125; 3、路由跳转通过下面的代码进行跳转12345ARouter.getInstance() .build(&quot;/kotlin/test&quot;) .withString(&quot;name&quot;, &quot;老王&quot;) .withInt(&quot;age&quot;, 23) .navigation(); build 和with方法组成Postcard（明信片）123456789101112131415161718com.alibaba.android.arouter.launcher.ARouter#navigation(java.lang.Class&lt;? extends T&gt;)com.alibaba.android.arouter.launcher._ARouter#navigation(java.lang.Class&lt;? extends T&gt;) protected &lt;T&gt; T navigation(Class&lt;? extends T&gt; service) &#123; try &#123; Postcard postcard = LogisticsCenter.buildProvider(service.getName()); // Compatible 1.0.5 compiler sdk. if (null == postcard) &#123; // No service, or this service in old version. postcard = LogisticsCenter.buildProvider(service.getSimpleName()); &#125; LogisticsCenter.completion(postcard); return (T) postcard.getProvider(); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); return null; &#125; &#125; 进行跳转123com.alibaba.android.arouter.facade.Postcard#navigation()com.alibaba.android.arouter.launcher.ARouter#navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback)com.alibaba.android.arouter.launcher._ARouter# navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) 在这个方法中会处理拦截器的逻辑 最终到123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263com.alibaba.android.arouter.launcher._ARouter#_navigation private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; final Context currentContext = null == context ? mContext : context; switch (postcard.getType()) &#123; case ACTIVITY: // Build intent final Intent intent = new Intent(currentContext, postcard.getDestination()); intent.putExtras(postcard.getExtras()); // Set flags. int flags = postcard.getFlags(); if (-1 != flags) &#123; intent.setFlags(flags); &#125; else if (!(currentContext instanceof Activity)) &#123; // Non activity, need less one flag. intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; // Navigation in main looper. new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; if (requestCode &gt; 0) &#123; // Need start for result ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle()); &#125; else &#123; ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle()); &#125; if ((-1 != postcard.getEnterAnim() &amp;&amp; -1 != postcard.getExitAnim()) &amp;&amp; currentContext instanceof Activity) &#123; // Old version. ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim()); &#125; if (null != callback) &#123; // Navigation over. callback.onArrival(postcard); &#125; &#125; &#125;); break; case PROVIDER: return postcard.getProvider(); case BOARDCAST: case CONTENT_PROVIDER: case FRAGMENT: Class fragmentMeta = postcard.getDestination(); try &#123; Object instance = fragmentMeta.getConstructor().newInstance(); if (instance instanceof Fragment) &#123; ((Fragment) instance).setArguments(postcard.getExtras()); &#125; else if (instance instanceof android.support.v4.app.Fragment) &#123; ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras()); &#125; return instance; &#125; catch (Exception ex) &#123; logger.error(Consts.TAG, &quot;Fetch fragment instance error, &quot; + TextUtils.formatStackTrace(ex.getStackTrace())); &#125; case METHOD: case SERVICE: default: return null; &#125; return null;]]></content>
      <categories>
        <category>read_fucking_source_code</category>
      </categories>
      <tags>
        <tag>read_fucking_source_code</tag>
        <tag>Arouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[read-fucking-source-code-lipland]]></title>
    <url>%2Fread-fucking-source-code-lipland.html</url>
    <content type="text"><![CDATA[本文主要分享Lipland一些核心代码和一些流程分析。 Read fucking source code:Lipland 关键技术说明插件化的技术，大量的使用了hook技术，而hook过程就是利用java的反射和动态代理，替换原有类中的属性对象或者 hook 原有类中的方法，一般情况下，如果属性对象是非final Class，可以直接写一个类继承目标Class，然后重写一些关键方法的实现过程；如果属性对象是接口或者一个final的Class，就需要通过动态代理去hook 那些方法。 第一种，替换属性对象，拿这个项目中的hook ActivityThread的Instrumentation为例：通过ActivityThread对象和class反射根据fieldName获取Instrumentation Field，强转为Instrumentation，然后把Instrumentation的所有属性都通过反射clone赋值给我们自己写的InstrumentationHacker，然后把InstrumentationHacker再通过反射重新设置回给ActivityThread，这样就把Instrumentation替换成InstrumentationHacker。 第二种，动态代理劫持方法,自己写一个InvocationHandler的实现类，在invoke方法中，通过方法名字的过滤，加上自己的逻辑处理，可以直接阻断原方法执行的逻辑，替换为自己的逻辑处理，简单的实例如下面的代码，我把MathOp接口中的sum方法劫持，把参数加大1012345678910111213141516171819202122232425262728293031323334353637383940414243444546public void addition_isCorrect() throws Exception &#123; MathOpImpl m = new MathOpImpl(); MathOp mi = (MathOp) Proxy.newProxyInstance( MathOpImpl.class.getClassLoader(), new Class&lt;?&gt;[]&#123;MathOp.class&#125;, new MInvokeHandler(m)); System.out.println(mi.sum(10, 2)); assertEquals(4, 2 + 2); &#125; class MInvokeHandler implements InvocationHandler &#123; MathOp mi; public MInvokeHandler(MathOp mi) &#123; this.mi = mi; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; System.out.println(&quot;before&quot;); if (method.getName().contains(&quot;sum&quot;)) &#123; int a = (int) args[0]; a += 10; args[0] = a; result = method.invoke(mi, args); &#125; else &#123; result = method.invoke(mi, args); &#125; System.out.println(&quot;after&quot;); return result; &#125; &#125; interface MathOp &#123; int sum(int a, int b); int max(int a, int b); &#125; class MathOpImpl implements MathOp &#123; public int sum(int a, int b) &#123; return a + b; &#125; @Override public int max(int a, int b) &#123; return a &gt; b ? a : b; &#125; &#125; 拿这个项目中的hook ActivityThread的ActivityManager的关键方法startService为例，关键InvokeHandler代码：12345678910111213141516171819202122232425262728293031323334@Overridepublic Object invoke(Object obj, Method method, Object[] args) throws Throwable &#123; if(hookHandler != null)&#123; if(!hookHandler.onBefore(origin, method, args)) return hookHandler.result; &#125; Object result = null; Throwable thr = null; try&#123; if(hookHandler != null)&#123; result = hookHandler.invoke(origin,method, args); &#125;else&#123; result = method.invoke(origin, args); &#125; &#125;catch(Throwable th)&#123; if(th instanceof InvocationTargetException)&#123; thr = ((InvocationTargetException) th).getTargetException(); &#125;else&#123; //doXXX() thr = th; &#125; &#125; try&#123; if(hookHandler != null)&#123; result = hookHandler.onAfter(origin, method, args, result,thr); &#125; &#125;catch(Exception e)&#123; Log.e(TAG, e); &#125; if(thr != null) throw thr; return result;&#125; 实现流程1.插件初始化12345678910111213141516public static boolean init(Application app)&#123; PluginHelper.app = app; if (!isPluginsSupport()) &#123; return false; &#125; //安装插件管理器，必须的步骤 PluginManager.setup(app); PluginManager pluginManager = PluginManager.getInstance(); //开启调试模式，调试模式下，打开日志。 //不验证插件签名 pluginManager.setDebug(true); pluginManager.setVerifySign(false); //配置插件管理器，可选 configure(); return true;&#125; 1.1 PluginManager初始化，pm.init(); ，然后 调用HostApplicationProxy.hook(app);12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static boolean setup(final Application app,final boolean startPluginProcess,boolean installDefaultPlugin,boolean forceInstallDefaultPlugin)&#123; HostGlobal.init(app); // 4.0以下版本不支持 if (android.os.Build.VERSION.SDK_INT &lt; VERSION_CODES.ICE_CREAM_SANDWICH) &#123; return false; &#125; if(!inited)&#123; final PluginManager pm = PluginManager.getInstance(); pm.init(); HostApplicationProxy.hook(app); pm.runInBackground(new Runnable() &#123; @Override public void run() &#123; NetworkManager.getInstance(app); app.registerComponentCallbacks(new ComponentCallbacks() &#123;、 @Override public void onLowMemory() &#123; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; // 同步插件中资源的onConfigurationChanged事件 Map&lt;String, Plugin&gt; plugins = PluginManager.getInstance().getPlugins(); for (Plugin p : plugins.values()) &#123; p.getRes().updateConfiguration(newConfig, app.getResources().getDisplayMetrics()); &#125; &#125; &#125;); if(pm.isMainProcess() &amp;&amp; startPluginProcess)&#123; PluginHelper.startPluginProcess(null); &#125; if(pm.isPluginProcess()) &#123;// if (installDefaultPlugin)// pm.installDefaultPlugins(forceInstallDefaultPlugin); pm.resetProxyActivitiesStatus();// //加载有loadOnAppStarted标志的插件，该标志表示在应用启动时在后台将插件加载到内存// //有这个标志的插件，启动相对会快一点，但是在没有启动时也会占用部分内存。// pm.loadPluginOnAppStarted(); &#125;// if(pm.isPluginProcess() &amp;&amp; startUpdate)&#123;// pm.startUpdate();// &#125; &#125; &#125;); inited = true; &#125; return true; &#125; 123456789101112131415161718192021222324252627282930313233343536373839static void hook(final Application app)&#123; activityThread = ActivityThread.currentActivityThread(); injectInstrumentation(activityThread); /** * 挂钩系统回调 */// SystemCallbackHacker.hook(activityThread); /** * 挂钩ActivityManager */// hookActivityManager(); //策略一 //默认主进程不挂钩PackageManager //也可以在启动完毕后，延迟挂钩，这样可以忽略性能影响// if(!HostGlobal.isMainProcess())&#123;// hookPackageManager();// &#125; //策略二 //主进程延迟500毫秒挂钩，等程序启动起来了再说 Runnable run = new Runnable() &#123; @Override public void run() &#123; hookActivityManager(); IClipboardHacker.hook(); ITelephonyHacker.hook(); IMountServiceHacker.hook(); INotificationManagerHacker.hook();// IAccessibilityManagerHacker.hook(); &#125; &#125;; initService(app); hookPackageManager(app); if(!HostGlobal.isMainProcess())&#123; run.run(); &#125;else&#123; new Handler().postDelayed(run, 500); &#125;// run.run();// hookAppOpsManager(); 1.2 PluginManager#init1.2.1、初始化，用Application注册了加载插件的监听1.2.2、初始化InstallManager，ActivityThread1.2.3com.qihoo.plugin.install.InstallManager#InstallManager 初始化1.2.3.1、初始化com.qihoo.plugin.update.UpdateManager，com.qihoo.plugin.update.UpdateManager#init1.2.3.2、com.qihoo.plugin.install.InstallManager#initData 1.3.1 hook ActivityThread的Instrumentation，替换为InstrumentationHacker,用来劫持startactivity一系列方法，启动代理Activity；1.3.2 hook ActivityThread的ActivityManager中的关键方法1.3.2.1 劫持startServic、bindService方法，在方法之前，经过一些判断，调用PluginManager.startService、bindService方法启动代理service；1.3.2.2 劫持stopService、stopServiceToken、unbindService方法，同样的在方法之前经过一些判断，调用pluginManager.stopService、stopServiceToken、unbindService来处理代理启动的service;1.3.2.3 劫持getIntentSender、getRunningAppProcesses、checkPermission、checkPermissionWithToken等方法1.3.3 hook其他的一些点1234IClipboardHacker.hook();ITelephonyHacker.hook();IMountServiceHacker.hook();INotificationManagerHacker.hook(); 1.3.4 hook PackageManager1.3.4.1 hook getPackageInfo方法用来处理插件的包信息，如果是宿主包名走原生逻辑，如果是插件，调用pluginManager.getInstallManager()来获取插件包信息1.3.4.2 hook getActivityInfo 方法 处理Activity的信息1.3.4.3 hook getApplicationInfo 方法 处理插件的 Application的信息1.3.4.4 hook queryIntentActivities 方法 处理查询activity的信息，扩展查询插件包里的activity 1.4 启动插件进程 PluginHelper.startPluginProcess(null);123456789101112131415161718192021pm.runInBackground(new Runnable() &#123; @Override public void run() &#123; NetworkManager.getInstance(app); app.registerComponentCallbacks(new ComponentCallbacks() &#123; @Override public void onLowMemory() &#123; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; // 同步插件中资源的onConfigurationChanged事件 Map&lt;String, Plugin&gt; plugins = PluginManager.getInstance().getPlugins(); for (Plugin p : plugins.values()) &#123; p.getRes().updateConfiguration(newConfig, app.getResources().getDisplayMetrics()); &#125; &#125; &#125;); if(pm.isMainProcess() &amp;&amp; startPluginProcess)&#123; PluginHelper.startPluginProcess(null); &#125; 1.4.1 启动 PluginProcessStartup这个service，在service内部去加载插件1234pluginManager.installDefaultPlugins(false);-&gt;InstallManager#install(PluginInfo,syncPreproccess)pluginManager.handlePendingInstallPlugin();-&gt;UpdateManager#installPlugin-&gt;InstallManager#install(PluginInfo,syncPreproccess) pluginManager.preproccess();pluginManager.loadPluginOnAppStarted(); pluginManager.installDefaultPlugins(false);内部去解析xml，然后copy 插件apk到插件目录，以及一些检测插件安全，然后预加载一次apk，具体就是DexClassLoader加载一次，把宿主的classloader传过来，用于加载类，重写loadClass方法，在调用super.loadClass找不到类的时候，尝试使用宿主的classloader去加载类 clazz = hostClassLoader.loadClass(className);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class DexClassLoaderEx extends BaseDexClassLoader &#123; private final static String TAG = DexClassLoaderEx.class.getSimpleName(); private ClassLoader hostClassLoader; private Context context; private String tag; private Map&lt;String,Map&lt;String,LibInfo&gt;&gt; libs; public DexClassLoaderEx(String tag,Map&lt;String,Map&lt;String,LibInfo&gt;&gt; libs,Context context,String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent, ClassLoader hostLoader) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); this.hostClassLoader = hostLoader; this.context = context; this.tag = tag; this.libs = libs; &#125; public Class&lt;?&gt; loadClassOrig(String className) throws ClassNotFoundException &#123; return super.loadClass(className); &#125; @Override public String findLibrary(String name) &#123; // TODO Auto-generated method stub if(libs != null)&#123; if(libs.containsKey(tag))&#123; Map&lt;String,LibInfo&gt; pLibs = libs.get(tag); if(pLibs.containsKey(name)) name = pLibs.get(name).mappingName; &#125; &#125; String filename = super.findLibrary(name); if(filename == null) return context.getApplicationInfo().nativeLibraryDir+&quot;/lib&quot;+name+&quot;.so&quot;; else return filename; &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; Log.d(TAG, &quot;loadClass [&quot; + className + &quot;]&quot;); Class&lt;?&gt; clazz = null; try &#123; try &#123; clazz = super.loadClass(className); &#125; catch (ClassNotFoundException e) &#123; Log.d(TAG, &quot;Class not found [&quot; + className + &quot;],try to find from the host class loader&quot;); clazz = hostClassLoader.loadClass(className); &#125; &#125; catch (java.lang.IllegalAccessError err) &#123; Log.e(TAG, &quot;className= [&quot; + className + &quot;],cl=&quot; + this + &quot;,parent=&quot; + this.getParent()); Log.e(TAG, &quot;className= [&quot; + className + &quot;],hostClassLoader=&quot; + hostClassLoader + &quot;,parent&quot; + hostClassLoader.getParent()); throw err; &#125; return clazz; &#125;&#125; 1.4.2pluginManager.loadPluginOnAppStarted();-&gt;PluginManager#load(String, IPluginLoadListener) 加载插件处理插件apk的所有四大组件信息，native 库，classloader，Resources1234DexClassLoaderEx classLoader = new DexClassLoaderEx(tag,libs,application, apkPath, Config.getDexWorkPath(tag), soPath, application.getClassLoader().getParent(), application.getClassLoader()); 处理Resources，PluginManager#loadResources(Context, String, boolean)，利用反射new一个AssetManager,然后把apk的目录通过反射调用addAssetPath方法加进去，然后new 一个Resources12345678910111213141516171819202122232425262728293031323334353637Object assetMag; Class&lt;?&gt; class_AssetManager = Class .forName(&quot;android.content.res.AssetManager&quot;); assetMag = class_AssetManager.newInstance(); Method method_addAssetPath = class_AssetManager.getDeclaredMethod( &quot;addAssetPath&quot;, String.class); method_addAssetPath.invoke(assetMag, path); // 5.0系统单独处理WebView// if (useWebView &amp;&amp; Build.VERSION.SDK_INT &gt;= 21) &#123;//// try &#123;// Class&lt;?&gt; cls = Class.forName(&quot;android.webkit.WebViewFactory&quot;);// Method getProviderMethod = cls.getDeclaredMethod(&quot;getProvider&quot;,// new Class[] &#123;&#125;);// getProviderMethod.setAccessible(true);//// getProviderMethod.invoke(cls);// PackageInfo pi = (PackageInfo) RefUtil.getFieldValue(cls,// &quot;sPackageInfo&quot;);// // String webViewAssetPath = pi.applicationInfo.sourceDir;// // String packageName = pi.packageName;// // application.getPackageManager().getPackageInfo(packageName,// // 0);// // Context webViewContext =// // application.createPackageContext(packageName,// // Context.CONTEXT_INCLUDE_CODE |// // Context.CONTEXT_IGNORE_SECURITY);// method_addAssetPath.invoke(assetMag,// pi.applicationInfo.sourceDir);// &#125; catch (Exception e) &#123;// e.printStackTrace();// &#125;// &#125; Resources res = application.getResources(); return new Resources((AssetManager) assetMag,res.getDisplayMetrics(), res.getConfiguration()) 1.3 检查插件更新 PluginManager#startUpdate(boolean, java.lang.Class&lt;? extends com.qihoo.plugin.update.UpdateFilter&gt;) 2 打开插件中的页面2.1 正常调用 startActivity，然后在InstrumentationHacker中，已经hook了actiivty启动的相关方法，主要功能是，判断是否是插件apk中的activity，如果是调用pluginManager.makeActivityIntent创建代理activity ProxyActivity的Intent，会把插件中Activity中信息放在Intent中，最终通过反射调用Android原生的Instrumentation 的execStartActivity方法，把目标为Activity的Intent包装成代理Activity-ProxyActivity的Intent2.2 hook newActivity方法，完全重写-&gt;createPluginActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private Activity createPluginActivity(Intent intent, String proxyClassName) &#123; CodeTraceTS.begin(&quot;createPluginActivity&quot;); Activity targetActivity = null; PluginManager pluginManager = PluginManager.getInstance(); String pTag = null; String targetClassName = null; try &#123; targetClassName = intent.getStringExtra(PluginManager.KEY_TARGET_CLASS_NAME); pTag = intent.getStringExtra(PluginManager.KEY_PLUGIN_TAG); &#125; catch (Exception e) &#123; Log.e(TAG, e); PluginManager.getInstance().postCrash(e); &#125; if (pTag == null) &#123; Log.e(TAG, &quot;createPluginActivity()::error,pTag=&quot; + pTag); &#125; Log.i(TAG, &quot;createPluginActivity()::pTag=&quot; + pTag); com.qihoo.plugin.bean.Plugin plugin = pluginManager.getPlugin(pTag); Log.i(TAG, &quot;createPluginActivity()::plugin=&quot; + plugin); if (plugin == null) &#123; Log.i(TAG, &quot;createPluginActivity()::Plugin is not loaded in the &quot; + (TextUtils.isEmpty(pluginManager.getName()) ? &quot;main&quot; : &quot;[&quot; + pluginManager.getName() + &quot;]&quot;) + &quot; process,tag=&quot; + pTag); plugin = pluginManager.load(pTag); if (plugin == null) return null; &#125; Log.i(TAG, &quot;createPluginActivity()::targetClassName=&quot; + targetClassName); ActivityInfo ai = plugin.findActivity(targetClassName);// if(ai.launchMode==ActivityInfo.LAUNCH_SINGLE_TASK// || ai.launchMode==ActivityInfo.LAUNCH_SINGLE_INSTANCE)&#123;// PluginContextInfo pci = getPluginContextInfo(pTag, targetClassName);// if (pci != null) &#123;// Activity act = (Activity)pci.context;// RefUtil.setFieldValue(act, &quot;mBase&quot;, null);// RefUtil.setFieldValue(act.getFragmentManager(), &quot;mActivity&quot;, null);// singleActivityCache.put(act, act);// act.setIntent(intent);// return (Activity)pci.context;// &#125;// &#125; if (targetClassName != null) &#123; Class&lt;?&gt; clz = null; try &#123; clz = plugin.getCl().loadClass(targetClassName); &#125; catch (Exception e) &#123; Log.e(TAG, e); Log.e(TAG, &quot;createPluginActivity()::Didn&apos;t find class &quot; + targetClassName); PluginManager.getInstance().postCrash(e); return null; &#125; try &#123; targetActivity = (Activity) clz.newInstance(); Log.i(TAG, &quot;createPluginActivity()::targetActivity=&quot; + targetActivity); &#125; catch (Error e) &#123; Log.e(TAG, &quot;createPluginActivity()::clz.newInstance(),error,e=&quot; + e); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;createPluginActivity()::clz.newInstance(),Exception,e=&quot; + e); &#125; // 缓存在当前正在运行的activity中 pluginContexts.put(targetActivity, new PluginContextInfo( targetActivity, plugin, proxyClassName, ai, intent)); TimeStatistics.getOrNewStartTimeInfo(pTag).activity_newActivity = CodeTraceTS.end(&quot;createPluginActivity&quot;).time(); return targetActivity; &#125; return null; &#125; 通过Intent获取插件中的目标Activity的classname，和KEY_PLUGIN_TAG，然后通过pluginManager根据KEY_PLUGIN_TAG获取相关的Plugin插件信息和插件中的目标Activity的类名，插件信息如下：123456789101112131415public class Plugin &#123; private String tag; private String path; private String srcPath; private Resources res; private DexClassLoaderEx cl; private ActivityInfo[] activityInfo; private IPlugin callback; private Application pluginApplication; private PackageInfo packageInfo; private PluginPackage pluginPackage; private LoadedApk loadedApk; private List&lt;WeakReference&lt;Activity&gt;&gt; activities; 通过插件的classloader去加载出插件中目标Activity的Class，通过反射newInstance new出插件中的目标Activity，这样就把ProxyActivity替换成为真正的目标Activity2.3 那Activity的生命周期呢，其实还是在InstrumentationHacker中，hook了Activity的生命周期的回调方法，如callActivityOnCreate，callActivityOnStart等方法，]]></content>
      <categories>
        <category>read_fucking_source_code</category>
      </categories>
      <tags>
        <tag>read_fucking_source_code</tag>
        <tag>Lipland</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[read-fucking-source-code-retrofit]]></title>
    <url>%2Fread-fucking-source-code-retrofit.html</url>
    <content type="text"><![CDATA[本文主要分享Retrofit一些核心代码和一些流程分析。 Read fucking source code:Retrofit 简单使用123456789101112Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); // Create an instance of our GitHub API interface. GitHub github = retrofit.create(GitHub.class); // Create a call instance for looking up Retrofit contributors. Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;); List&lt;Contributor&gt; contributors = call.execute().body(); for (Contributor contributor : contributors) &#123; System.out.println(contributor.login + &quot; (&quot; + contributor.contributions + &quot;)&quot;); &#125; 1234new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); 组织参数构建出一个Retrofit，参数包括url，请求参数组装工程类，返回数据转换工程类。1234567891011121314151617181920212223242526retrofit2.Retrofit#createpublic &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); &#125; &#125;); &#125; 方法会返回一个动态代理生成的 GitHub接口。然后下面调用1Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(&quot;square&quot;, &quot;retrofit&quot;); 在动态代理中，执行method，先通过loadServiceMethod，在缓存中找出包装过Method的 ServiceMethod对象，ServiceMethod对象在初始化的时候，会把Retrofit中的所有参数和上面的数据转换的工程类对象都拿到，以及 接口中定义的方法上所携带的所有注解，包括方法注解，和参数注解，参数注解会转换为ParameterHandler的子类和注解的名字一样的子类名字，方便后面使用12345678910111213141516171819202122232425262728293031323334353637result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); ServiceMethod(Builder&lt;R, T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; this.httpMethod = builder.httpMethod; this.relativeUrl = builder.relativeUrl; this.headers = builder.headers; this.contentType = builder.contentType; this.hasBody = builder.hasBody; this.isFormEncoded = builder.isFormEncoded; this.isMultipart = builder.isMultipart; this.parameterHandlers = builder.parameterHandlers; // 方法中定义的参数的注解 &#125; public ServiceMethod build() &#123; callAdapter = createCallAdapter(); private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType); &#125; if (returnType == void.class) &#123; throw methodError(&quot;Service methods cannot return void.&quot;); &#125; Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType); &#125; &#125; 返回一个 DefaultCallAdapterFactory，然后封装为OkHttpCall，OkHttpCall提供了同步执行的方法或者异步执行的方法，和创建 okhttp3.Call 的方法 okhttp3.Call toCall(@Nullable Object… args)，而 toCall 方法中会有 okhttp3.Call.Factory callFactory;最后1234serviceMethod.adapt(okHttpCall); T adapt(Call&lt;R&gt; call) &#123; return callAdapter.adapt(call); &#125; 将请求转换为一个Call请求执行的代理对象，在这个例子中其实就是上面的OkHttpCall，还有其他的转换器，如RxJava2CallAdapter，会把请求转为一个Observable]]></content>
      <categories>
        <category>read_fucking_source_code</category>
      </categories>
      <tags>
        <tag>read_fucking_source_code</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[read_fucking_source_code_hermeseventbus]]></title>
    <url>%2Fread-fucking-source-code-hermeseventbus.html</url>
    <content type="text"><![CDATA[本文主要分享Hermeseventbus和Eventbus一些核心代码和一些流程分析。 Read fucking source code:hermeseventbus Hermeseventbus和Eventbus区别在于Hermeseventbus利用Hermes这个Android IPC库来在多进程直接传递发送出来的event。接下来就先分析一下Eventbus的原理和流程，然后再来分析Hermeseventbus的原理和流程。 Eventbus分析原理就是通过反射拿到注册的订阅者的class中有Subscribe注解的方法和相关信息，并缓存起来以便下次订阅的时候不用重新再反射一遍，然后把订阅者放进订阅集合中，有事件发送的时候直接调用mehtod.invoke方法调用订阅方法 1、注册123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 注册过程通过subscriberMethodFinder去获取subscriber中用注解定义的方法和一些其他信息，如下1234567final Method method; final ThreadMode threadMode; final Class&lt;?&gt; eventType; final int priority; final boolean sticky; /** Used for efficient comparison */ String methodString; 然后通过subscribe(subscriber, subscriberMethod);方法把订阅者的信息放进要观察的集合中1.1 先从METHOD_CACHE中通过subscriberClass找是否有换成，然后通过findUsingReflection-&gt;findUsingReflectionInSingleClass12345678910111213141516171819List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 123456789private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 1.2findUsingReflectionInSingleClass通过反射分析Subscribe注解，来确定SubscriberMethod信息。123456789101112131415161718192021222324252627282930313233343536private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125;&#125; 2、发送eventpost-&gt;postSingleEvent-&gt;postSingleEventForEventType-&gt;postToSubscription-&gt;invokeSubscriber or org.greenrobot.eventbus.HandlerPoster#enqueue-&gt;invokeSubscriber12345678910111213141516171819202122/** Posts the given event to the event bus. */public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; postToSubscription方法通过该时间类型所对应注册的方法的线程模型，来决定是直接执行invokeSubscriber还是把事件放进对应的PendingPostQueue中去，PendingPostQueue是一个双向链表123456789void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(&quot;Unexpected exception&quot;, e); &#125;&#125; invokeSubscriber就直接拿之前已经解析出来的method调用method.invoke方法3、unregister就简单了，只是从订阅者集合中删除了这个订阅者 Hermeseventbus分析其实Hermeseventbus的核心原理是Hermes这个库，其他方面就是对多进程IPC传递数据的封装。还是一点一点深入。原理HermesEventBus的github上已经分享过了。如下12345678910111213事件收发是基于EventBus，IPC通信是基于Hermes。Hermes是一个简单易用的Android IPC库。本库首先选一个进程作为主进程，将其他进程作为子进程。每次一个event被发送都会经过以下四步：1、使用Hermes库将event传递给主进程。2、主进程使用EventBus在主进程内部发送event。3、主进程使用Hermes库将event传递给所有的子进程。4、每个子进程使用EventBus在子进程内部发送event。]]></content>
      <categories>
        <category>read_fucking_source_code</category>
      </categories>
      <tags>
        <tag>read_fucking_source_code</tag>
        <tag>hermeseventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[read_fucking_source_code_leakcanary]]></title>
    <url>%2Fread-fucking-source-code-leakcanary.html</url>
    <content type="text"><![CDATA[本文主要分享leakcanary的一些核心代码和一些流程分析。 Read fucking source code:leakcanary 关键代码1234567891011121314151617com.squareup.leakcanary.LeakCanary#install public static RefWatcher install(Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall(); &#125; public static AndroidRefWatcherBuilder refWatcher(Context context) &#123; return new AndroidRefWatcherBuilder(context); &#125; public RefWatcher buildAndInstall() &#123; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; LeakCanary.enableDisplayLeakActivity(context); ActivityRefWatcher.install((Application) context, refWatcher); ==》com.squareup.leakcanary.ActivityRefWatcher#install &#125; return refWatcher; &#125; 12345678910111213141516171819202122232425262728293031public static void install(Application application, RefWatcher refWatcher) &#123; new ActivityRefWatcher(application, refWatcher).watchActivities(); &#125; private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new Application.ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity); &#125; &#125;;void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity); &#125; 12345678910111213141516171819202122public void watch(Object watchedReference, String referenceName) &#123; if (this == DISABLED) &#123; return; &#125; checkNotNull(watchedReference, &quot;watchedReference&quot;); checkNotNull(referenceName, &quot;referenceName&quot;); final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString(); retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); ensureGoneAsync(watchStartNanoTime, reference);&#125;private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; watchExecutor.execute(new Retryable() &#123; @Override public Retryable.Result run() &#123; return ensureGone(reference, watchStartNanoTime); &#125; &#125;);&#125; 12345678910111213141516171819202122232425262728293031Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); removeWeaklyReachableReferences(); if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. return RETRY; &#125; if (gone(reference)) &#123; return DONE; &#125; gcTrigger.runGc(); removeWeaklyReachableReferences(); if (!gone(reference)) &#123; long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap. return RETRY; &#125; long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); heapdumpListener.analyze( new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; return DONE;&#125; 1234567Override public void execute(Retryable retryable) &#123; if (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123; waitForIdle(retryable, 0); &#125; else &#123; postWaitForIdle(retryable, 0); &#125; &#125; 1234567void postWaitForIdle(final Retryable retryable, final int failedAttempts) &#123; mainHandler.post(new Runnable() &#123; @Override public void run() &#123; waitForIdle(retryable, failedAttempts); &#125; &#125;);&#125; 123456789void waitForIdle(final Retryable retryable, final int failedAttempts) &#123; // This needs to be called from the main thread. Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; postToBackgroundWithDelay(retryable, failedAttempts); return false; &#125; &#125;);&#125; 123456789101112void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) &#123; long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor); long delayMillis = initialDelayMillis * exponentialBackoffFactor; backgroundHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Retryable.Result result = retryable.run(); if (result == RETRY) &#123; postWaitForIdle(retryable, failedAttempts + 1); &#125; &#125; &#125;, delayMillis);&#125; 步骤分析1、refWatcher(application) 返回一个AndroidRefWatcherBuilder建造者2、.listenerServiceClass(DisplayLeakService.class) 指定分析Heapdump的listener3、.excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) 排除一些已知的Android系统以及各个手机场数系统内存泄露的问题4、buildAndInstall() 创建出RefWatcher，然后ActivityRefWatcher.install((Application) context, refWatcher); 设置Application.ActivityLifecycleCallbacks，监听Activity的生命周期回调，在onActivityDestroyed方法中开始观察这个activity5、refWatcher.watch(activity);为这个activity生成一个UUID，加入缓存keyset中，创建一个KeyedWeakReference，使用同一个ReferenceQueue6、ensureGoneAsync方法用于确认activity有没有被正常回收，com.squareup.leakcanary.AndroidWatchExecutor#execute，7、12345mainHandler.post(new Runnable() &#123; @Override public void run() &#123; waitForIdle(retryable, failedAttempts); &#125; &#125;); 使用handler把处理Looper.myQueue().addIdleHandler的任务加进messagequeue中，8、Looper.myQueue().addIdleHandler 添加一个监听MessageQueue空闲等待新的message的监听，然后在123public boolean queueIdle() &#123; postToBackgroundWithDelay(retryable, failedAttempts);&#125; 处理对于reference的检测处理9、1Retryable.Result result = retryable.run(); ==&gt;1com.squareup.leakcanary.RefWatcher#ensureGoneAsync ==&gt;1com.squareup.leakcanary.Retryable#run ==&gt;1com.squareup.leakcanary.RefWatcher#ensureGone 10、ensureGone方法中，第一次removeWeaklyReachableReferences(),检测ReferenceQueue中有已经标记要gc但还没有进行gc的对象，那么就从第5步骤中keyset删除上次的UUID；retryJava 在debug的时候的情况，不需要去dumpheap1234gcTrigger.runGc(); 执行一次gcRuntime.getRuntime().gc(); enqueueReferences(); System.runFinalization(); gone(reference))方法用来确认这次要处理的reference是否在removeWeaklyReachableReferences()的时候已经删除了key，11、如果已经删除了说明刚才已经标记要gc掉，那么就return DONE结束了，12、否则就要开始处理heap, File heapDumpFile = heapDumper.dumpHeap();先将内存dump出来存进文件，13、dumpHeap过程使用了CountDownLatch弹出一个toast，弹出toast之后给looper添加IdleHandler，在looper空闲时，把toast设置给FutureResult，然后回到dumpHeap()过程中，调用Debug.dumpHprofData(heapDumpFile.getAbsolutePath());开始dump内存到hprof文件中去14、然后调用之前设置的listener进行分析，heapdumpListener.analyze==》com.squareup.leakcanary.HeapAnalyzer#checkForLeak，分析过程， 知识拓展CountDownLatch都有哪些使用场景。1、实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。2、开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。3、死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。这篇文章分析的不错]]></content>
      <categories>
        <category>read_fucking_source_code</category>
      </categories>
      <tags>
        <tag>read_fucking_source_code</tag>
        <tag>leakcanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 github+hexo 搭建个人博客]]></title>
    <url>%2Fbuild-blog-with-github-hexo.html</url>
    <content type="text"><![CDATA[本文内容包括：1、基于 github hexo 搭建博客2、基于 git branch 来管理 hexo 环境3、基于 git submodule 管理主题基于以上3点，用一个 github repository 就既可以用来搭建博客，也可以用来管理 hexo 环境，又可以管理自己的主题配置，而更重要的是我们这样就解决了换一个工作空间之后需要重新配置一套 hexo环境的麻烦问题。另外还有：4、使用 github sync 使自己 forked 的主题 repository 和主仓库保持同步5、绑定域名 环境准备：git npm nodejs hexo知识准备：熟悉 git 命令，github 基本操作 创建一个 github.io 仓库管理 blog 分支和 hexo 分支你可能会问为啥要 blog 分支和 hexo 分支，因为我想仅使用一个 git 仓库就可以完成写博客、发布博客、存储的的需求，至于为什么，且往下看，一步一步你就会明白。 创建一个github.io仓库并创建hexo分支在 github上创建一个名为 teffy.github.io 的仓库，默认生成的 master 分支为我们博客存储的分支，再创建 hexo 分支用做写博客和发布博客环境的存储分支。12345#在github 上创建 teffy.github.io，很简单git clone git@github.com:teffy/teffy.github.io.gitcd teffy.github.io # 进入仓库根目录git checkout -b hexo # 创建 hexo 分支git push origin hexo:hexo # push hexo 分支到远程 设置hexo分支为主分支 本地搭建博客先在本地搭建一下，然后再提交到远程。 hexo 初始化进入 git 仓库 teffy.github.io 根目录1hexo init teffy.github.io 这样会生成 teffy.github.io 这样一个目录，和我们的git仓库名这样就重复了，我们需要把 hexo 生成的环境移动到仓库根目录12mv teffy.github.io/* ./ #把hexo生成的 teffy.github.io 下所有文件移动到 git 仓库根目录rmdir teffy.github.io #删除 hexo init 生成的 teffy.github.io 目录 那么你可能会问，为啥不在 teffy.github.io 目录的上一级执行 hexo init teffy.github.io ，这样不就省去了这一步吗？那是因为 hexo init 要求后面的目录是一个空目录，而 teffy.github.io 是一个 git 仓库，里面就算没有其他文件也会有一个.git隐藏文件，所以无法这么操作。 测试本地博客在teffy.github.io目录下，注意切换到 hexo 分支，查看分支 git branch ，切换分支 git checkout hexo 。1hexo s # 完整命令 hexo server 在浏览器里打开 http://localhost:4000/ 就可以看到本地博客的效果。 测试一下发布 blog先在 git 仓库 根目录安装 hexo-deployer-git1npm install hexo-deployer-git --save 我们先来测试一下发布，打开_config.yml，修改最下面的Deployment12345Deployment ，我使用的是git， repository就是teffy.github.io的仓库地址，这里用https，注意还要要指定branch为master，因为master是我们的blog静态文件所存储的分支deploy: type: git repository: https://github.com/teffy/teffy.github.io.git branch: master 发布一下1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 然后访问一下 http://teffy.github.io 看看是否发布成功。 提交hexo环境到githubhexo 环境已经OK了，我们就把这套 hexo 环境提交到github上，在这之前先配置一下 .gitignore ，要不然会把一些不必要的文件也提交上去。1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 提交到 github 。1234git add .git commit -m &quot;hexo env&quot;# 这里注意是 hexo 分支git push orign hexo 换一个工作空间继续写博客到此为止，我们整个 blog 和 hexo 环境都已经全部创建完成，而且我们可以做到随意换一个工作空间就可以继续写博客了。Waht ???这么做就可以了？是的，那么，先来测试一把看看。这里我就在电脑换个目录操作来模拟换一个工作空间继续写博客，当然真实情况一般是换了电脑，那就还需要将各种环境工具先安装好，然后 clone 下来我们的仓库之后，在 hexo 分支上，先安装一下 hexo ，然后就可以像刚才一样愉快的玩耍了。1234567891011121314151617181920212223242526➜ blog: mkdir test➜ blog: cd test➜ test: git clone git@github.com:teffy/teffy.github.io.git➜ test: cd teffy.github.io➜ teffy.github.io git:(hexo): git status位于分支 hexo➜ teffy.github.io git:(hexo): hexo s #这里先本地测试一下，会提示这个仓库没有安装hexo，按照提示安装一下ERROR Local hexo not found in ~/Workspace/blog/test/teffy.github.ioERROR Try running: &apos;npm install hexo --save&apos; #提示在这➜ teffy.github.io git:(hexo) npm install hexo --save # 安装hexo+ hexo@3.4.4added 329 packages in 7.519s➜ teffy.github.io git:(hexo) ✗ hexo s #再来一次INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.^CINFO Catch you later➜ teffy.github.io git:(hexo) ✗ vim source/_posts/hello-world.md #修改一下文章测试一下呢➜ teffy.github.io git:(hexo) ✗ hexo s # 换个姿势，再来一次INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.^CINFO Good bye# 接下来测试能不能发布➜ teffy.github.io git:(hexo) ✗ hexo clean &amp;&amp; hexo g &amp;&amp; hexo dINFO Deleted database.INFO …… # 省略部分logINFO Deploy done: git 再去访问一下 http://teffy.github.io 看看我们的修改是否发布成功。OK，我们在新的环境中做的修改就可以提交上去了。12345git statusgit diffgit add .git cm -m &quot;modify test&quot;git push origin hexo 那我们再切回老的目录的时候（相当于切换回原来的工作空间）只需要 git pull 更新一下就可以了。 使用git submodule 管理主题虽然已经把blog和hexo环境都搞好了，而且还只用一个git仓库就管理了blog和hexo，更重要的是，还有可以随便换电脑都能写博客这种骚操作，还有更骚的吗？答案是有的，接下来我们要用 git submodule 来管理自己喜欢的主题，在这之前，你应该知道的是一般主题的开发者也都是使用github托管。你可能会问，主题还用管理吗，直接放在仓库里不就OK了，当然那样是可以的，但是后续如果主题的开发者有什么更新，我们想更新就会非常麻烦，基本是石器时代的感觉，而我们使用git submoudle就是单车变摩托的感觉了。这样我们博客和主题的仓库就分开进行管理了，主题仓库作为博客仓库的一个子模块。 添加 git submodule我使用的是 Next 主题，我们先来 fork 一份，以便后续我们可以同步主仓库的更新。之后在我们的 git 仓库中的 themes 目录下把刚才 fork 的主题 git 仓库添加到我们的博客的仓库中的 git submodule 。1234cd themesgit submodule add git@github.com:teffy/hexo-theme-next.gitgit commit -m &quot;add next theme submodule&quot;git push origin hexo 先来测试一下 Next 主题，修改 _config.yml 中主题配置12# theme: landscapetheme: hexo-theme-next 本地测试看一下效果，然后提交到 github 上去。1234hexo sgit add .git commit -m &quot;use next theme&quot;git push origin hexo 管理主题仓库来看看怎么管理主题呢，做一个简单的主题配置修改12345678910# cd 进入 themes/hexo-theme-next 目录，修改 _config.ymlgit add .git commit -m &quot;update config&quot;git push origin master# 然后回到 teffy.github.io 仓库根目录cd ../..git status #可以看到 修改： themes/hexo-theme-next (新提交)git add .git cm -m &quot;theme update&quot;git push origin hexo 换工作空间之后管理主题那么问题来了，就是我们切换工作空间了之后主题仓库怎么办？除了之前说的需要安装几个工具和 git 操作之外，还需要再处理一下主题，接着在刚才的新的工作空间里操作一下。12345678910git pull # 先更新Fast-forward .gitmodules | 3 +++ _config.yml | 17 ++++++++++------- themes/hexo-theme-next | 1 +# 这里通过git log 就可以看到有主题的更新，但是这里只是更新了 submodule ，会生成一个 submodule 仓库的空目录，而真正主题的仓库文件还没有更新到这个新的工作空间中teffy.github.io git:(hexo) ll themes/hexo-theme-next总用量 0 # 这里可以看出是个空目录git submodule initgit submodule update #这样就可以将主题仓库中的文件更新下来 更新完主题之后可以 hexo s 本地测试一下，妥妥的。 同步主题主仓库的更新那么问题又来了，如果主题的开发者有了更新，我fork的主题仓库怎么同步主仓库的更新呢，我们可以使用 git fetch 命令来进行1234567git remote add upstream https://github.com/iissnan/hexo-theme-next.git # 先指定上游主仓库git fetch upstream # 更新主仓库内容git status # 查看是否有更新git checkout master # 切换回 master 分支git merge upstream/master # 将上游 master 分支和自己的 master 分支合并# 这里有可能会有冲突，那么解决一下冲突然后，需要 git add . 和 git commit 一下git push origin master # 最后将这些主仓库 master 分支的改动提交到我们自己的仓库中去 写博客说了这么多，还没说怎么写博客呢。1hexo new &quot;first_blog&quot; 然后使用 markdown 编辑器写好文章之后，先本地看下效果之后，就可以部署到 github上了，当然还要把这些新的文章提交到 hexo 环境中去，以便换了工作空间还可以对已经发布的文章修改。1234hexo clean &amp;&amp; hexo g &amp;&amp; hexo dgit add .git commit -m &quot;new blog&quot;git push orign hexo # 这里注意是 hexo 分支 markdown include 插件这里我推荐一款插件 markdown include有点问题 绑定域名上面的步骤做完之后已经可以愉快的写博客了，那么再加上一个个性化的域名是不是更加完美？恩，你说啥就是啥！ 买个域名买域名就不详细说了，各个域名服务商的操作都很简单，准备好 money 就行了，只说一点，国外域名服务商不需要备案，国内的需要备案。 配置 github 仓库在我们的 仓库的 hexo 分支下，source目录新建个CNAME文件，里面写上买好的域名，然后重新部署一下就 OK 了。 配置 DNS在域名服务商的管理控制页面添加两条A记录和一个CNAME记录。 Host(主机记录) 记录类型 Points To(记录值) @ A 192.30.252.153 @ A 192.30.252.154 www CNAME teffy.github.io 配置 dnspod如果是在国外域名服务商买的域名，由于墙太高的原因，最好使用国内域名服务器，我使用的是 dnspod，注册登录之后和刚才一样添加两条A记录和一个CNAME记录。然后回到国外域名服务商的管理控制页面，修改 DNS 服务器。123# 域名服务器f1g1ns1.dnspod.netf1g1ns2.dnspod.net 最后喝杯茶等一会就生效了，直接访问域名 http://teffy.me 试试。 ##Teffy的小尾巴谢谢阅读本文，如果觉得对你有帮助，不妨分享给你的好友或者打赏一波也是棒棒哒~(@^_^@)~]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
